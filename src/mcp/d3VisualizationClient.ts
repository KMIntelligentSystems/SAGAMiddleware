import { MCPClientManager } from './mcpClient.js';
import * as path from 'path';
import * as fs from 'fs';

export interface D3VisualizationOptions {
  d3Code: string;          // Complete HTML document with D3 visualization (generated by LLM agent)
  htmlSetup?: string;      // NOT USED - d3Code should be the complete HTML document
  data?: string;           // Optional additional data to inject via JavaScript
  outputPath?: string;     // Where to save outputs
  screenshotName?: string; // PNG filename
  svgName?: string;        // SVG filename
}

export interface D3RenderResult {
  success: boolean;
  screenshotPath?: string;
  svgPath?: string;
  error?: string;
}

/**
 * D3VisualizationClient
 *
 * Wrapper around Playwright MCP server for rendering D3 visualizations
 * Integrates with the existing MCP client infrastructure
 */
export class D3VisualizationClient {
  private mcpClient: MCPClientManager;
  private serverName: string;

  constructor(mcpClient: MCPClientManager, serverName: string = 'playwright-server') {
    this.mcpClient = mcpClient;
    this.serverName = serverName;
  }

  /**
   * Render D3 visualization using Playwright MCP server
   */
  async renderD3(options: D3VisualizationOptions): Promise<D3RenderResult> {
    try {
      console.log('üé® Starting D3 visualization rendering...');
      console.log(`üîç Checking connection to server: ${this.serverName}`);

      // Debug: List all connected servers
      const connectedServers = this.mcpClient.getConnectedServers();
      console.log(`üìã Connected servers: ${connectedServers.join(', ')}`);

      // Check if connected to Playwright MCP server
      if (!this.mcpClient.isConnected(this.serverName)) {
        console.error(`‚ùå Server '${this.serverName}' is not connected`);
        console.error(`üí° Available servers: ${connectedServers.join(', ')}`);
        console.error(`üí° Make sure Playwright MCP server is connected during initialization`);
        throw new Error(`Playwright MCP server '${this.serverName}' is not connected. Available: ${connectedServers.join(', ')}`);
      }

      console.log(`‚úÖ Connected to ${this.serverName}`);

      // D3 code is always a complete HTML document generated by the LLM agent
      // Use playwright_set_content to load the HTML directly
      console.log('üìÑ Loading D3 HTML document via playwright_set_content...');

      await this.mcpClient.callTool(this.serverName, {
        name: 'playwright_set_content',
        arguments: {
          html: options.d3Code,  // d3Code is the complete HTML document
          waitUntil: 'networkidle'  // Wait for D3 library and all resources to load
        }
      });

      console.log('‚úÖ D3 HTML document loaded successfully');

      // Inject additional data if provided (optional - for dynamic data injection)
      if (options.data) {
        console.log('üíæ Injecting additional data...');
        await this.mcpClient.callTool(this.serverName, {
          name: 'playwright_evaluate',
          arguments: {
            script: `
              window.userData = ${JSON.stringify(options.data)};
              'Data stored';
            `
          }
        });
      }

      // Prepare output directory
      const outputDir = options.outputPath || path.join(process.cwd(), 'output', 'd3-visualizations');
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      // Save PNG screenshot
      const screenshotName = options.screenshotName || `d3-visualization-${Date.now()}.png`;
      const screenshotPath = path.join(outputDir, screenshotName);
      console.log(`üì∏ Taking screenshot to ${screenshotPath}...`);

      await this.mcpClient.callTool(this.serverName, {
        name: 'playwright_screenshot',
        arguments: {
          path: screenshotPath,
          fullPage: true
        }
      });

      // Save SVG
      const svgName = options.svgName || `d3-visualization-${Date.now()}.svg`;
      const svgPath = path.join(outputDir, svgName);
      console.log(`üíæ Saving SVG to ${svgPath}...`);

      await this.mcpClient.callTool(this.serverName, {
        name: 'playwright_save_svg',
        arguments: { path: svgPath }
      });

      console.log('‚úÖ Visualization complete!');
      console.log(`  üì∏ PNG: ${screenshotPath}`);
      console.log(`  üíæ SVG: ${svgPath}`);

      return {
        success: true,
        screenshotPath,
        svgPath
      };
    } catch (error) {
      console.error('‚ùå D3 visualization error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Render D3 code and return paths to generated files
   * Convenience method for simple use cases
   */
  async renderD3Code(d3Code: string, outputName?: string): Promise<D3RenderResult> {
    const baseName = outputName || `visualization-${Date.now()}`;
    return this.renderD3({
      d3Code,
      screenshotName: `${baseName}.png`,
      svgName: `${baseName}.svg`
    });
  }

  /**
   * Close browser (cleanup)
   */
  async close(): Promise<void> {
    try {
      if (this.mcpClient.isConnected(this.serverName)) {
        await this.mcpClient.callTool(this.serverName, {
          name: 'playwright_close',
          arguments: {}
        });
        console.log('üîí Browser closed');
      }
    } catch (error) {
      console.error('‚ùå Error closing browser:', error);
    }
  }
}