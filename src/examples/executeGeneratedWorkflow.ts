/**
 * Execute Generated Workflow
 *
 * Loads agent structures generated by agentStructureGenerator.ts
 * and executes them using SagaWorkflow with cheap models
 *
 * Benefits:
 * - Expensive model (Sonnet) only used for planning
 * - Execution uses cheap models (gpt-4o-mini)
 * - Full control over execution flow
 * - Uses existing SagaWorkflow + MCP infrastructure
 */

import { SagaCoordinator } from '../coordinator/sagaCoordinator.js';
import { mcpClientManager } from '../mcp/mcpClient.js';
import { AgentDefinition, MCPServerConfig } from '../types/index.js';
import * as fs from 'fs';
import * as path from 'path';

interface WorkflowSpec {
    name: string;
    description: string;
    agents: Array<{
        agentDefinition: AgentDefinition;
        purpose: string;
        expectedInput: string;
        expectedOutput: string;
        executionOrder?: number;
    }>;
    executionFlow: string[];
    context: Record<string, any>;
}

/**
 * Workflow Executor using SagaCoordinator
 */
export class GeneratedWorkflowExecutor {
    private coordinator: SagaCoordinator;
    private mcpServers: Record<string, MCPServerConfig>;

    constructor() {
        // Configure MCP servers (same as sagaWorkflow.ts)
        this.mcpServers = {
            execution: {
                name: "execution-server",
                transport: "stdio",
                command: "node",
                args: ["C:/repos/codeGen-mcp-server/dist/server.js", "--stdio"],
                timeout: 300000
            }
        };

        this.coordinator = new SagaCoordinator(this.mcpServers);
    }

    /**
     * Load workflow specification from JSON file
     */
    loadWorkflow(filePath: string): WorkflowSpec {
        console.log(`\n📂 Loading workflow from: ${filePath}`);

        if (!fs.existsSync(filePath)) {
            throw new Error(`Workflow file not found: ${filePath}`);
        }

        const content = fs.readFileSync(filePath, 'utf-8');
        const spec: WorkflowSpec = JSON.parse(content);

        console.log(`✅ Loaded workflow: ${spec.name}`);
        console.log(`   Agents: ${spec.agents.length}`);
        console.log(`   Execution flow: ${spec.executionFlow.join(' → ')}\n`);

        return spec;
    }

    /**
     * Execute the workflow
     */
    async executeWorkflow(spec: WorkflowSpec): Promise<void> {
        console.log('\n╔═══════════════════════════════════════════════════════════════╗');
        console.log(`║  Executing Workflow: ${spec.name.padEnd(43)} ║`);
        console.log('╚═══════════════════════════════════════════════════════════════╝\n');

        try {
            // Connect to MCP servers
            console.log('🔌 Connecting to MCP servers...');
            await mcpClientManager.connect(this.mcpServers.execution);
            console.log('✅ Connected to execution-server\n');

            // Register all agents
            console.log('📋 Registering agents...');
            for (const agent of spec.agents) {
                this.coordinator.registerAgent(agent.agentDefinition);
                console.log(`   ✓ ${agent.agentDefinition.name}`);
            }
            console.log();

            // Execute agents in order
            console.log('🚀 Executing workflow...\n');
            for (const agentName of spec.executionFlow) {
                await this.executeAgent(agentName, spec.context);
            }

            console.log('\n' + '═'.repeat(70));
            console.log('✅ Workflow completed successfully!');
            console.log('═'.repeat(70) + '\n');

        } catch (error) {
            console.error('\n❌ Workflow execution failed:', error);
            throw error;
        } finally {
            // Cleanup
            console.log('🧹 Disconnecting from MCP servers...');
            await mcpClientManager.disconnect('execution-server');
            console.log('✅ Cleanup complete\n');
        }
    }

    /**
     * Execute a single agent
     */
    private async executeAgent(agentName: string, context: Record<string, any>): Promise<void> {
        console.log('─'.repeat(70));
        console.log(`Executing: ${agentName}`);
        console.log('─'.repeat(70));

        const agent = this.coordinator.agents.get(agentName);
        if (!agent) {
            throw new Error(`Agent not found: ${agentName}`);
        }

        const startTime = Date.now();
        const result = await agent.execute(context);
        const duration = Date.now() - startTime;

        if (result.success) {
            console.log(`✅ ${agentName} completed in ${duration}ms`);
            if (result.result) {
                console.log(`   Output: ${result.result.substring(0, 200)}`);
            }
        } else {
            console.error(`❌ ${agentName} failed:`, result.error);
            throw new Error(`Agent ${agentName} failed: ${result.error}`);
        }

        console.log();
    }

    /**
     * Display execution summary
     */
    displaySummary(spec: WorkflowSpec): void {
        console.log('\n╔═══════════════════════════════════════════════════════════════╗');
        console.log('║                      Execution Summary                         ║');
        console.log('╚═══════════════════════════════════════════════════════════════╝\n');

        console.log(`Workflow: ${spec.name}`);
        console.log(`Description: ${spec.description}\n`);

        console.log('Agents Executed:');
        spec.executionFlow.forEach((name, idx) => {
            const agent = spec.agents.find(a => a.agentDefinition.name === name);
            if (agent) {
                console.log(`  ${idx + 1}. ${name}`);
                console.log(`     Model: ${agent.agentDefinition.llmConfig.model}`);
                console.log(`     Type: ${agent.agentDefinition.agentType}`);
            }
        });

        console.log('\nOutput Files:');
        if (spec.context.outputFiles) {
            spec.context.outputFiles.forEach((file: string) => {
                const exists = fs.existsSync(file);
                console.log(`  ${exists ? '✅' : '❌'} ${file}`);
            });
        }
    }
}

/**
 * Main execution
 */
export async function main() {
    // Check for API keys
    if (!process.env.OPENAI_API_KEY && !process.env.ANTHROPIC_API_KEY) {
        console.error('❌ ERROR: Neither OPENAI_API_KEY nor ANTHROPIC_API_KEY is set');
        process.exit(1);
    }

    const args = process.argv.slice(2);
    const workflowPath = args[0] || './generated_workflows/energy_data_processing.json';

    try {
        const executor = new GeneratedWorkflowExecutor();

        // Load workflow
        const spec = executor.loadWorkflow(workflowPath);

        // Execute workflow
        await executor.executeWorkflow(spec);

        // Display summary
        executor.displaySummary(spec);

        console.log('\n✅ Complete workflow finished!\n');

    } catch (error) {
        console.error('\n✗ Error executing workflow:', error);
        if (error instanceof Error) {
            console.error('Stack trace:', error.stack);
        }
        process.exit(1);
    }
}

// Auto-run main when executed directly
if (import.meta.url === `file://${process.argv[1].replace(/\\/g, '/')}`) {
    main().catch(console.error);
}
